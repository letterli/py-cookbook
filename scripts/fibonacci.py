#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
用python实现斐波那契数列
"""

##################################################################################
# 递归法
#
# 递归是一种代码最简洁的方法，但它效率非常低，因为会出现大量的重复计算，时间复杂度是：O(1.68^n)
# 同时受限于python中递归的最大深度是1000，所以用递归来求解并不是一种可取的方法。
###################################################################################

def fib_recur(n):
    assert n >= 0
    if n in (0, 1):
        return n
    return fib_recur(n-1) + fib_recur(n-2)


####################################################################################
# 递推法
#
# 这种算法的时间复杂是O(n),呈线性增长，如果数据量巨大，速度越到后面会越慢。
###################################################################################

def fib_loop(n):
    a, b = 0, 1
    for i in range(n):
        a, b = b, a + b
    return a

####################################################################################
# 矩阵法
#
# 该算法时间复杂度为O(log n)
#
#  F(n) = F(n-1) + F(n-2)
#
# [  Fn     ]     [Fn-1 + Fn-2]      [1xFn-1 + 1xFn-2]      [1   1]      [Fn-1]
# |         | =   |           |  =   |               |  =   |     |  x   |    |
# [  Fn-1   ]     [   Fn-1    ]      [1xFn-1 + 0xFn-2]      [1   0]      [Fn-2]
#
# [  Fn-1     ]     [Fn-2 + Fn-3]      [1xFn-2 + 1xFn-3]      [1   1]      [Fn-2]
# |           | =   |           |  =   |               |  =   |     |  x   |    |
# [  Fn-2     ]     [   Fn-2    ]      [1xFn-2 + 0xFn-3]      [1   0]      [Fn-3]
#
# [  Fn     ]     [1  1] n-1          [1] F1
# |         | =   |    |        x     | |
# [  Fn-1   ]     [1  0]              [0] F0
###################################################################################

import numpy

def fib_matr(n):
    return (numpy.matrix([[1, 1], [1, 0]]) ** (n-1) * numpy.matrix([[1], [0]]))[0, 0]

